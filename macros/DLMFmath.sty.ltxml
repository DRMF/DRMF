# -*- CPERL -*-
# /=====================================================================\ #
# |  DLMFmath                                                           | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #

# Currently only a random collection of things I need for DLMF chapters.
# Eventually, go through the doc and implement it all.
#**********************************************************************
package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;
use LaTeXML::Util::KeyVal;

#**********************************************************************
# Load special functions & other required packages.
RequirePackage('amssymb');

#**********************************************************************
# General Math Constructs

DefMath('\Real',      "\x{211D}", role=>'ID', meaning=>'reals'); # DOUBLE-STRUCK CAPITAL R
DefMath('\Complex',   "\x{2102}", role=>'ID', meaning=>'complexes'); # DOUBLE-STRUCK CAPITAL C
DefMath('\NatNumber', "\x{2115}", role=>'ID', meaning=>'numbers'); # DOUBLE-STRUCK CAPITAL N
DefMath('\Integer',   "\x{2124}", role=>'ID', meaning=>'integers'); # DOUBLE-STRUCK CAPITAL Z
DefMath('\Rational',  "\x{211A}", role=>'ID', meaning=>'rationals'); # DOUBLE-STRUCK CAPITAL Q
DefMath('\Polynomial',"\x{2119}", role=>'ID', meaning=>'polynomials'); # DOUBLE-STRUCK CAPITAL P

DefMath('\HalfComplex',"\x{210D}", role=>'ID', meaning=>'upper-complexes'); # DOUBLE-STRUCK CAPITAL H
# Redefined here, since Frank doesn't like the Fraktur.
DefMath('\Re',       "Re", role=>'OPFUNCTION', meaning=>'real-part');
DefMath('\Im',       "Im", role=>'OPFUNCTION', meaning=>'imaginary-part');

DefMath('\realpart{}', "\x{211C}", meaning=>'real-part'); # BLACK-LETTER CAPITAL R
DefMath('\imagpart{}', "\x{2111}", meaning=>'imaginary-part'); # BLACK-LETTER CAPITAL I
DefMath('\conj{}',     UTF(0xAF),  meaning=>'conjugate', operator_role=>'OVERACCENT');


# NOTE: I'm redefining this here to use a reverse-solidus (U+005C) instead of the "proper" U+2216,
# since firefox displays the latter SOOOOOO small that it looks totally wrong.
### DefMathI('\setminus',  undef,"\x{2216}", role=>'ADDOP', meaning=>'set-minus');
DefMathI('\setminus',  undef,UTF(0x5C), role=>'ADDOP', meaning=>'set-minus');

# Convoluted to get presentation to revert to i,e, etc, but content as \iunit, etc.
DefMath('\iunit',"\x{2148}",
	role=>'ID', meaning=>'imaginary-i',
	reversion=>sub {
	  (($LaTeXML::DUAL_BRANCH||'') eq 'presentation' ? T_LETTER('i') : T_CS('\iunit')); });
DefMath('\expe', "\x{2147}",
	role=>'ID', meaning=>'exponential-e',
	reversion=>sub {
	  (($LaTeXML::DUAL_BRANCH||'') eq 'presentation' ? T_LETTER('e') : T_CS('\expe')); });
DefMath('\cpi',"\x{03C0}",
	role=>'ID', meaning=>'circular-pi',
	reversion=>sub {
	  (($LaTeXML::DUAL_BRANCH||'') eq 'presentation' ? T_CS('\pi') : T_CS('\cpi')); });
DefMath('\diffd',"\x{2146}",
	role=>'DIFFOP', meaning=>'differential-d',
	reversion=>sub {
	  (($LaTeXML::DUAL_BRANCH||'') eq 'presentation' ? T_LETTER('d') : T_CS('\diffd')); });

DefMacro('\opminus',   "(-1)");

# \cfrac covered in amsmath.
AssignValue(CFRACSTYLE=>'inline'); # But our default is inline.

# \midvert, \midVert ??

DefMath('\floor{}','\left\lfloor#1\right\rfloor', meaning=>'floor');
DefMath('\ceiling{}','\left\lceil#1\right\rceil', meaning=>'ceiling');

DefMath('\divides','|', role=>'MULOP', meaning=>'divides');
DefMath('\abs{}', '\left|#1\right|', meaning=>'absolute-value');
DefMath('\card{}', '\left|#1\right|', meaning=>'cardinality'); # cardinality of a set.
DefMath('\pgcd{}', '\left(#1\right)', meaning=>'gcd');

DefMath('\cartprod','\times',role=>'MULOP',meaning=>'cartesian-product');
DefMath('\setmod',  '/',     role=>'MULOP',meaning=>'set-modulus');

#**********************************************************************
DefConstructor('\selection{}',
	       "<ltx:XMApp>"
	       . "<ltx:XMTok name='selection' role='STACKED'/>"
	       . "<ltx:XMArg rule='Anything,'>#1</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       bounded=>1, beforeDigest=>sub{
		 DefConstructor("\\\\ OptionalMatch:* [Dimension]",
				"</ltx:XMArg><ltx:XMArg rule='Anything,'>",
				reversion=>Tokens(T_CS("\\\\"),T_CR)); });

DefConstructor('\rselection{}',
	       "<ltx:XMApp close='}'>"
	       . "<ltx:XMTok name='selection' role='STACKED'/>"
	       . "<ltx:XMArg rule='Anything,'>#1</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       bounded=>1, beforeDigest=>sub{
		 DefConstructor("\\\\ OptionalMatch:* [Dimension]",
				"</ltx:XMArg><ltx:XMArg rule='Anything,'>",
				reversion=>Tokens(T_CS("\\\\"),T_CR)); });

DefConstructor('\lselection{}',
	       "<ltx:XMApp open='{'>"
	       . "<ltx:XMTok name='selection' role='STACKED'/>"
	       . "<ltx:XMArg rule='Anything,'>#1</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       bounded=>1, beforeDigest=>sub{
		 DefConstructor("\\\\ OptionalMatch:* [Dimension]",
				"</ltx:XMArg><ltx:XMArg rule='Anything,'>",
				reversion=>Tokens(T_CS("\\\\"),T_CR)); });

DefConstructor('\lrselection{}',
	       "<ltx:XMApp open='{' close='}'>"
	       . "<ltx:XMTok name='selection' role='STACKED'/>"
	       . "<ltx:XMArg rule='Anything,'>#1</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       bounded=>1, beforeDigest=>sub{
		 DefConstructor("\\\\ OptionalMatch:* [Dimension]",
				"</ltx:XMArg><ltx:XMArg rule='Anything,'>",
				reversion=>Tokens(T_CS("\\\\"),T_CR)); });

#**********************************************************************
# Numbers
#   \Sci{mantisa}{exponent}
my %SUPDIGITS = (0=>"\x{2070}",1=>UTF(0xb9),2=>UTF(0xb2),3=>UTF(0xb3),4=>"\x{2074}",
		 5=>"\x{2075}",6=>"\x{2076}",7=>"\x{2077}",8=>"\x{2078}",9=>"\x{2079}",
		'+'=>"\x{207a}", '-'=>"\x{207b}");
sub sci_to_unicode {
  my($mantissa,$exponent)=@_;
  $mantissa = ToString($mantissa);
  $mantissa =~ s/\\,/\x{2009}/g;
  $mantissa =~ s/\\:/\x{2005}/g;
  $mantissa =~ s/\\;/\x{2004}/g;
  $mantissa =~ s/\\ /\x{2002}/g;
  $mantissa =~ s/\\!//g;
  $exponent = ToString($exponent);
  ($exponent
   ? join('',$mantissa,UTF(0xD7)."10",map($SUPDIGITS{$_}||'?',split('',$exponent))) 
   : $mantissa . UTF(0xA0).UTF(0xA0).UTF(0xA0)); } # for alignment spacing???

sub sci_to_text {
  my($mantissa,$exponent)=@_;
  $mantissa = ToString($mantissa);
  $mantissa =~ s/(\\,|\\:|\\;|\\ |\\!|\s)//g;
  $exponent = ToString($exponent);
  $exponent =~ s/(\\,|\\:|\\;|\\ |\\!|\s)//g;
  $exponent = "+".$exponent if $exponent && $exponent !~ /^(\+|\-)/;
  ($exponent ? join('',$mantissa,"e",$exponent) : $mantissa); }

DefConstructor('\Sci{}{}',sub {
  my($document,$mantissa,$exponent,%props)=@_;
  my $string = sci_to_unicode($mantissa,$exponent);
  ($props{isMath} 
   ? $document->insertMathToken($string,font=>$props{font},
				role=>'NUMBER',meaning=>sci_to_text($mantissa,$exponent))
   : $document->openText($string,$props{font})); });

# Worry about alignment later...
#DefMacro('\TSci{}{}','\multicolumn{2}{r}{\Sci{#1}{#2}}');

DefConstructor('\Sci@Exp{}',
	       sub { my($document,$exp,%props)=@_;
		     $exp = ToString($exp);
		     if($exp ne ''){
		       $document->insertMathToken(sci_to_unicode("",$exp),
						  font=>$props{font}, role=>'NUMBER',
						  meaning=>sci_to_text("1.0",$exp)); }},
	      reversion=>sub { my $exp = $_[0]->getArg(1);
			      ($exp->unlist ? (T_CS('\times'),T_OTHER('1'),T_OTHER('0'),
					       T_SUPER,T_BEGIN,$exp->revert,T_END)
			       :()); },
	      font=>{shape=>'upright'});
DefMacro('\TSci{}{}','\ensuremath{#1} & \ensuremath{\Sci@Exp{#2}}');

#**********************************************************************
# Calculus
# Derivatives are handled slightly tricky, since we have an optional power,
# and want to treat them as a differential operator if the numerator is empty.
# operator, instead of a derivative.

sub checkDiffOp {
  my($whatsit)=@_;
  my $f = $whatsit->getArg(2);
  !$f || !($f->unlist) || !($f->getArg(2)->unlist); }

DefMath('\deriv[]{}{}',
	'\frac{\@MAYBEAPPLY{\@SUPERSCRIPT{\diffd}{#1}}{#2}}'
	.    '{\@SUPERSCRIPT{\@APPLY{\diffd #3}}{#1}}',
	meaning=>'derivative', reorder=>[2,3,1],
	afterDigest=>sub{
	  # NOTE: arg 2 will be wrapped in XMRef!
	  $_[1]->setProperty(role=>'DIFFOP') if checkDiffOp($_[1]);
	  return;});
DefMath('\pderiv[]{}{}',
	'\frac{\@MAYBEAPPLY{\@SUPERSCRIPT{\partial}{#1}}{#2}}'
	.    '{\@SUPERSCRIPT{\@APPLY{\partial #3}}{#1}}',
	meaning=>'partial-derivative', reorder=>[2,3,1],
	afterDigest=>sub{
	  # NOTE: arg 2 will be wrapped in XMRef!
	  $_[1]->setProperty(role=>'DIFFOP') if checkDiffOp($_[1]);
	  return;});
DefMath('\ideriv[]{}{}',
	'\ifrac{\@MAYBEAPPLY{\@SUPERSCRIPT{\diffd}{#1}}{#2}}'
	.     '{\@SUPERSCRIPT{\@APPLY{\diffd #3}}{#1}}',
	meaning=>'derivative', reorder=>[2,3,1],
	afterDigest=>sub{
	  # NOTE: arg 2 will be wrapped in XMRef!
	  $_[1]->setProperty(role=>'DIFFOP') if checkDiffOp($_[1]);
	  return;});
DefMath('\ipderiv[]{}{}',
	'\ifrac{\@MAYBEAPPLY{\@SUPERSCRIPT{\partial}{#1}}{#2}}'
	.     '{\@SUPERSCRIPT{\@APPLY{\partial #3}}{#1}}',
	meaning=>'partial-derivative', reorder=>[2,3,1],
	afterDigest=>sub{
	  # NOTE: arg 2 will be wrapped in XMRef!
	  $_[1]->setProperty(role=>'DIFFOP') if checkDiffOp($_[1]);
	  return;});

# \Deriv[n]{z} => D^2_z
# \qDeriv[n]{q}{z} => D^2_{q,z}
# Games to reorder the args. (for content)
DefMath('\Deriv[]{}','\@SUBSCRIPT{\@SUPERSCRIPT{D}{#1}}{#2}',
	reorder=>[2,1], role=>'DIFFOP',meaning=>'differential-operator');
DefMath('\qDeriv[]{}{}','\@SUBSCRIPT{\@SUPERSCRIPT{D}{#1}}{#2,#3}',
	reorder=>[2,3,1], role=>'DIFFOP',meaning=>'q-differential-operator');

# Games to reorder the args. (for content)
DefMath('\diff[]{}','\@APPLY{\@SUPERSCRIPT{\diffd}{#1}#2}',
	reorder=>[2,1], meaning=>'differential');
DefMath('\pdiff[]{}','\@APPLY{\@SUPERSCRIPT{\partial}{#1}#2}',
	reorder=>[2,1], meaning=>'partial-differential');
DefMath('\qdiff[]{}{}',
	'\@APPLY{\@SUPERSCRIPT{\@SUBSCRIPT{\diffd}{#2}}{#1} #3}',
	reorder=>[2,3,1], meaning=>'q-differential');


# Forward, Backward and Central differences operator
DefMath('\fDiff []','\Delta_{#1}',role=>'DIFFOP',
       meaning=>'forward-difference');
DefMath('\bDiff []','\nabla_{#1}',role=>'DIFFOP',
       meaning=>'backward-difference');
DefMath('\cDiff []','\delta_{#1}',role=>'DIFFOP',
       meaning=>'central-difference');
#**********************************************************************
DefMath('\pvint',  "\x{2A0D}", meaning=>'principal-value-integral', role=>'INTOP',
	mathstyle=>\&doVariablesizeOp);
DefMath('\Residue', "res",    meaning=>"residue", role=>'LIMITOP');

#**********************************************************************
# Types

# Defined differently from DLMFmath.sty because of subtle bugs(?) in LaTeXML
DefConditional('\if@testletter {}', sub { ToString($_[1]) =~ /^[a-zA-Z]$/; });
# NOTE: these are lacking any recording of the fact that the argument is a Vector, Matrix,...!!!!!
DefMacro('\Vector{}','\if@testletter{#1}\ROLE{ID}{\mathbf{#1}}\else \boldsymbol{{#1}}\fi');
DefMacro('\Matrix{}','\if@testletter{#1}\ROLE{ID}{\mathbf{#1}}\else \boldsymbol{{#1}}\fi');
DefMacro('\Lattice{}','\ROLE{ID}{\mathbb{#1}}');

DefMath('\dotprod',  '\cdot', role=>'MULOP',meaning=>'inner-product');
DefMath('\crossprod','\times',role=>'MULOP',meaning=>'cross-product');

DefMath('\divergence', "div",  role=>'DIFFOP', meaning=>'divergence');
DefMath('\curl',       "curl", role=>'DIFFOP', meaning=>'curl');
DefMath('\gradient',   "grad", role=>'DIFFOP', meaning=>'gradient');
DefMath('\transpose{}','#1^{\mathrm{T}}', meaning=>'transpose');
DefMath('\trace',      "tr",   role=>'LIMITOP', meaning=>'trace');
DefMath('\diag',       "diag", role=>'LIMITOP', meaning=>'diagonal');

#**********************************************************************
# Combinatorics
DefConstructor('\binomial{}{}',
	       "<ltx:XMApp open='(' close=')'>"
	       . "<ltx:XMTok meaning='binomial' role='STACKED' mathstyle='#mathstyle'/>"
	       . "<ltx:XMArg>#1</ltx:XMArg><ltx:XMArg>#2</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       beforeDigest=>\&beforeFrac, afterDigest =>\&afterFrac);
DefConstructor('\multinomial{}{}',
	       "<ltx:XMApp open='(' close=')'>"
	       . "<ltx:XMTok meaning='multinomial' role='STACKED' mathstyle='#mathstyle'/>"
	       . "<ltx:XMArg>#1</ltx:XMArg><ltx:XMArg>#2</ltx:XMArg>"
	       ."</ltx:XMApp>",
	       beforeDigest=>\&beforeFrac, afterDigest =>\&afterFrac);

DefMath('\pochhammer{}{}',  '\left(#1\right)_{#2}', meaning=>'Pochhammer');
DefMath('\psfactorial{}{}',  '\left[#1\right]_{#2}',
	meaning=>'shifted-factorial');
DefMath('\wigner{}{}{}{}{}{}',
	'\left(#1 \@INVISIBLECOMMA #2 \@INVISIBLECOMMA #3 \@INVISIBLECOMMA #4'
	.'| #1 \@INVISIBLECOMMA #3 \@INVISIBLECOMMA #5 \@INVISIBLECOMMA #6\right)',
	meaning=>'Wigner');

DefMath('\Kronecker{}{}','\delta_{#1,#2}',
	meaning=>'Kronecker');
DefMath('\LeviCivita{}{}{}','\epsilon_{#1,#2,#3}',
	meaning=>'Levi-Civita');
DefMath('\deltaDistribution[]','\delta_{#1}',
	meaning=>'delta-distribution');
DefMath('\Distribution{}{}','\left\langle #1,#2\right\rangle',
	meaning=>'distribution');
DefMath('\Schwarzian{}{}','\left\{ #1,#2\right\}',
	meaning=>'Schwarzian');

DefMath('\qFactorial{}{}{}','\left(#1;#2\right)_{#3}',
	meaning=>'q-factorial');
DefMath('\qBinomial{}{}{}', '\genfrac[]\z@{}{#1}{#2}_{#3}',
	meaning=>'q-binomial');

DefMacro('\threej OptionalKeyword:@',
	      sub { my($gullet,$at)=@_;
		    ($at ? (T_CS('\threej@args')):(T_CS('\threej@text'))); });
DefMacro('\sixj OptionalKeyword:@',
	      sub { my($gullet,$at)=@_;
		    ($at ? (T_CS('\sixj@args')):(T_CS('\sixj@text'))); });
DefMacro('\ninej OptionalKeyword:@',
	      sub { my($gullet,$at)=@_;
		    ($at ? (T_CS('\ninej@args')):(T_CS('\ninej@text'))); });
DefMath('\threej@text','3j', role=>'ID', reversion=>'3j',meaning=>'threej');
DefMath('\sixj@text',  '6j', role=>'ID', reversion=>'6j',meaning=>'sixj');
DefMath('\ninej@text', '9j', role=>'ID', reversion=>'9j',meaning=>'ninej');
DefMath('\threej@args {}{}{}{}{}{}',
	'\begin{pmatrix}#1&#2&#3\\\\ #4&#5&#6\end{pmatrix}',
	meaning=>'threej');
DefMath('\sixj@args {}{}{}{}{}{}',
	'\begin{Bmatrix}#1&#2&#3\\\\ #4&#5&#6\end{Bmatrix}',
	meaning=>'sixj');
DefMath('\ninej@args {}{}{}{}{}{}{}{}{}',
	'\begin{Bmatrix}#1&#2&#3\\\\ #4&#5&#6\\\\ #7&#8&#9\end{Bmatrix}',
	meaning=>'ninej');

# Paper over for AbstractJacobi
DefMacro('\AbstractJacobi{}{}','\AbstractJacobiPQ{\mathrm{#1#2}}');
DefMacro('\arcAbstractJacobi{}{}','\arcAbstractJacobiPQ{\mathrm{arc#1#2}}');

# Recognize !! as double factorial
DefMathLigature(sub { my($document,@nodes)=@_;
		      if((scalar(@nodes) >= 2)
			 && ! grep( ($document->getModel->getNodeQName($_) ne 'ltx:XMTok')||($_->textContent ne "!"),
				    @nodes[$#nodes-1 .. $#nodes])){
			(2, "!!", meaning=>'double-factorial', role=>'POSTFIX'); }});


#**********************************************************************
# Constants
DefMath('\EulerConstant',"\x{03B3}", role=>'ID',
	meaning=>'Euler-constant'); # GREEK SMALL LETTER GAMMA
DefMath('\BoltzmannConstant',"k", role=>'ID',
	meaning=>'Boltzmann-constant');
DefMath('\RydbergConstant','R_\infty',    role=>'ID',
	meaning=>'Rydberg-constant');
DefMath('\lightspeed',     'c',           role=>'ID',
	meaning=>'speed-of-light');
DefMath('\finestructure','\alpha',        role=>'ID',
	meaning=>'fine-structure-constant');
DefMath('\ElectricConstant','\epsilon_0', role=>'ID',
	meaning=>'electric-constant');
DefMath('\BohrRadius','a_0', role=>'ID',
	meaning=>'Bohr-radius');

#**********************************************************************
# Special Functions
DefPrimitive('\specFunObsolete{}{}',sub {
  my($defn,$old,$new)=@_;
  DefMacro("\\".ToString($old),"\\".ToString($new)); });

sub count_tokens {
  my($gullet,$token)=@_;
  my $n=0;
  while($gullet->readMatch($token)){ $n++; }
  $n; }

#**********************************************************************

DefPrimitive('\defSpecFun{}[][]{} OptionalKeyVals:DefSpecFun {}', sub {
  my($stomach,$name,$nparam,$optparam,$formatter,$keys,$nargs)=@_;
  my $gullet = $stomach->getGullet;
  $name=ToString($name);
  my $cs = '\\'.$name;
  $nargs  = ToString($nargs);
  my $role = ($keys && ToString($keys->getValue('role'))) 
    || ($nargs ?  'FUNCTION' : 'ATOM');
  my $meaning = ($keys && ToString($keys->getValue('meaning'))) || $name;
  DefMacroI(T_CS($cs.'@role'),undef,Tokens(T_OTHER($role)));
  # A bit of craziness.
  # DLMFfcns redefines \sin, etc to take @-form args, etc.
  # However, unless we're careful, UnTeX'ing these will result in
  # tex properties having \mathrm{sin} instead of \sin!!!
  if(my $prevdefn = LookupDefinition(T_CS($cs))){ # Already defined (by LaTeX?)
    if(($prevdefn->getLocator =~ /(La)?TeX.pool/) # Simple defn, defined by TeX or LaTeX.
       && !LookupDefinition(T_CS($cs.'@presentation'))
       && !LookupDefinition(T_CS($cs.'@content'))){
      # We need to get at the original definition, but Let won't work,
      # since reversion/invocation/... gives you the real cs name; You end up infinite recursion.
      # So,we try to recreate the definition under \cs@original.
      my $props = $$prevdefn{properties};
      my $origrole = ($props && (ref $props eq 'HASH') && $$props{role});
      my $origmeaning = ($props && (ref $props eq 'HASH') && $$props{meaning}) || $name;
      my $orig = T_CS($cs.'@original');
      DefMathI($orig,undef,$name,role=>$role,alias=>$cs, meaning=>$meaning);
      $formatter = Tokens($orig); }}
  # Define with DefMath to create presentation & content cs's
  DefMathI($cs,convertLaTeXArgs($nparam,$optparam),
	   "\\PRESENTATION\@OP{$role}{".UnTeX($formatter)."\\/}\\nolimits",
	   role=>$role, operator_role=>$role, meaning=>$meaning, omcd=>'dlmf');
  # Then, redefine top-level macro to check for powers, args, etc.
  DefMacroI($cs,convertLaTeXArgs($nparam,$optparam),
	    sub { expand_specfun($cs,$nargs,@_); });

  # Read any argument formats & generate args macros
  my @argfmts=();
  while(my $af = $gullet->readOptional){
    push(@argfmts,$af); }
  push(@argfmts, Tokenize("\\!\\left(".join(',',map("#$_",1..$nargs))."\\right)"))
    unless @argfmts;
  for(my $i=0; $i <= $#argfmts; $i++){
    DefMacroI(T_CS(join('',$cs,'@args',('@' x ($i+1)))),
	      convertLaTeXArgs($nargs,undef),
	      UnTeX($argfmts[$i])); }

  $gullet->skipSpaces;
  return; });

DefConstructor('\sf@apply{}{}', "<ltx:XMApp>#1#2</ltx:XMApp>",
  reversion => sub {
    my($fcn,$args) = $_[0]->getArgs;
    ($fcn->revert,T_OTHER("@"),map( (T_BEGIN,$_->revert,T_END), $args->unlist)); });

DefMacro('\@PRIMES{}',sub { ((T_CS('\prime')) x ToString($_[1])); });
##### DefMath('\diffop{}{}','{{#1}^{\@PRIMES{#2}}}');
DefMath('\diffop{}{}','{#1^{\@PRIMES{#2}}}');
DefMath('\power{}{}',"{#1^{#2}}", meaning=>'power');

DefMacro('\@BEAPPLIED{}',sub {
  my($gullet,$argsform)=@_;
  my @tokens = Expand($argsform)->unlist;
  (scalar(@tokens) ? (T_CS('\@APPLYFUNCTION'),@tokens) : ()); });

##DefMacro('\@BEAPPLIED{}',sub {
##  my($gullet,$argsform)=@_;
##  (scalar($argsform->unlist) ? (T_CS('\@APPLYFUNCTION'),$argsform) : ()); });

DefConstructor('\PRESENTATION@OP{}{}', "<ltx:XMWrap role='#1'>#2</ltx:XMWrap>",
	       reversion=>'\mathop{#2}');

sub expand_specfun {
  my($cs,$nargs,$gullet,@params)=@_;
  my($cparams,$pparams)=dualize_arglist(@params);
  my $ccall = Invocation(T_CS($cs.'@content'),@$cparams);
  my $pcall = Invocation(T_CS($cs.'@presentation'),@$pparams);
  $gullet->skipSpaces;
  # Check for following primes and superscripts, and wrap the function appropriately.
  while(my $op = $gullet->readMatch(T_OTHER("'"),T_SUPER)){ # Hmm, ' is active only in math?
    if($op->equals(T_SUPER)){
      # NOTE: Before I go assuming that ^{x} is a power, consider analyzing for things like ^{(n)} !!!
      my($cpower,$ppower) = dualize_arglist($gullet->readArg); # Should do xmref here too!!!
      $ccall = Invocation(T_CS('\power@content'),$ccall,@$cpower);
      $pcall = Invocation(T_CS('\power@presentation'),$pcall,@$ppower); }
    else{
      my $n = 1+count_tokens($gullet,$op);
      $ccall = Invocation(T_CS('\diffop@content'),$ccall,T_OTHER($n));
      $pcall = Invocation(T_CS('\diffop@presentation'),$pcall,T_OTHER($n));}}
  $gullet->skipSpaces;
  # Check for function arguments
  if(my $variant = count_tokens($gullet,T_OTHER('@'))){
    my $argsmacro = LookupDefinition(T_CS($cs.'@args'.('@' x $variant)));
    $argsmacro = LookupDefinition(T_CS($cs.'@args@')) unless $argsmacro;
    my($cargs,$pargs)=dualize_arglist($argsmacro->readArguments($gullet));
    Invocation(T_CS('\DUAL'),
	       T_OTHER('ATOM'),
	       Invocation(T_CS('\sf@apply'),$ccall,Tokens(map((@$_),@$cargs))),
#####	       Tokens($pcall->unlist, T_CS('\@APPLYFUNCTION'), $argsmacro->invocation(@$pargs))
	       Tokens($pcall->unlist, Invocation(T_CS('\@BEAPPLIED'),Tokens($argsmacro->invocation(@$pargs)))->unlist)
		  )->unlist; }
  else {
##    Invocation(T_CS('\DUAL'),
##	       T_OTHER(($nargs ? 'FUNCTION' : 'ATOM')), $ccall, $pcall)->unlist}; }
    Invocation(T_CS('\DUAL'),T_CS($cs.'@role'), $ccall, $pcall)->unlist}; }

#**********************************************************************
# Now, load the special functions
#my $p = "$ENV{HOME}/dlmf/styles/DLMFtex";
#UnshiftValue(SEARCHPATHS=>$p) unless grep($p eq $_,@{LookupValue('SEARCHPATHS')});
# RequirePackage('DLMFfcns', notex=>0);
RequirePackage('DRMFfcns', notex=>0);
#**********************************************************************
1;

